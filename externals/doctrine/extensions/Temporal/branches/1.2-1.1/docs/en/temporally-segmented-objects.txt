Dealing with Temporal data will very soon lead to this common problem:

* A child (LicenseAssignments) points to a parent (Subscription) with a temporal parent/child relationship.
* The parent starts in the past (eff_date < $today)
* The parent is modified - for instance, the subscription license count is incremented

Since the parent starts in the past, a new temporal segment must be created:

    [php]
    $new_segment = $subscription->createNewTemporalSegment(); // NOTE: this returns a Subscription object.
    $new_segment->licenses++;
    $new_segment->save();

Now we have two Subscription records that conceptually refer to the same subscription, and the license assignments will have to be carried forward manually:

    [php]
    foreach ($subscription->LicenseAssignments as $la) {
        $new_la = new LicenseAssignment();
        $new_la->setArray(array(
            'customer_id'       => $la->customer_id,
            'subscription_id'   => $la->subscription_id,
            'eff_date'          => $new_segment->eff_date,
            'exp_date'          => $new_segment->exp_date,
        ));
        $new_la->save();
    }

Additionally, this code would have to handle exceptions for things like past dates, overlaps, etc. as well as any other custom logic
for the model it is dealing with. The code gets hairy pretty fast! 
This problem can be described as the consequence of not satisfying the rule that "one record should represent one real-world entity". 
When multiple records represent the same object, normalization is broken and maintenance and integrity issues multiply.

To retain normalization without modifying past records, the "Temporally Segmented Object" database pattern should be followed.
This pattern is described by Martin Fowler at [http://martinfowler.com/ap2/temporalObject.html](http://martinfowler.com/ap2/temporalObject.html).
When implementing this pattern in Doctrine, use the TemporallySegmentedObject behavior, which is an extension of the standard Temporal behavior.

Here is the subscription model, modified to take advantage of the TSO pattern (refer to 'Options' for the original yml spec):

> **NOTE**
> To take advantage of Temporal Segment features, the relationship from the parent to the child must be named `Segments`. 

    [yml]
    Subscription:
        actAs: 
            TemporallySegmentedObject:
                allow_past_modifications:   false
                unique_fields:              [group_id, product_id]
                children:                   [LicenseAssignments]
                parent_alias:               Subscription
        columns:
            id:
                type:           integer(10)
                unsigned:       true
                primary:        true
                autoincrement:  true
            group_id:           # the user group that the subscription is assigned to
                type:           integer(10)
                unsigned:       true
                notnull:        true
            product_id:
                type:           integer(10)
                unsigned:       true
                notnull:        true
            licenses:
                type:           integer(2)
                unsigned:       true
                notnull:        true
        relations:
            LicenseAssignments:
                class:          LicenseAssignment
                local:          id
                foreign:        subscription_id
                foreignAlias:   Subscription
                type:           many

The TemporallySegmentedObject template will do a few things for you automatically:

* Split the Subscription model in two: Subscription and SubscriptionSegment
* Add primary and foreign keys to SubscriptionSegment
* Move the `licenses` field into SubscriptionSegment, so that Subscription only has fields that define temporal uniqueness. (`licenses` is the only field which is neither a `primary` column, or a member of the `unique_fields` array)
* Add a `Segments` relationship from Subscription to SubscriptionSegment, and add a `Subscription` relationship from SubscriptionSegment to Subscription, and define them as temporal parent/temporal child (see 'Options' for more info on this concept)

The two models generated by the TemporallySegmentedObject template are equivalent to:

    [yml]
    Subscription:
        actAs: 
            Temporal:
                allow_past_modifications:   false
                unique_fields:              [group_id, product_id]
                children:                   [LicenseAssignments, Segments]
        columns:
            id:
                type:           integer(10)
                unsigned:       true
                primary:        true
                autoincrement:  true
            group_id:           # the user group that the subscription is assigned to
                type:           integer(10)
                unsigned:       true
                notnull:        true
            product_id:
                type:           integer(10)
                unsigned:       true
                notnull:        true
        relations:
            LicenseAssignments:
                class:          LicenseAssignment
                local:          id
                foreign:        subscription_id
                foreignAlias:   Subscription
                type:           many
            Segments:
                class:          SubscriptionSegment
                local:          id
                foreign:        subscription_id
                foreignAlias:   Subscription    # NOTE: this name is set using the 'parent_alias' config option in the TemporallySegmentedObject template.
                type:           many
                cascade:        [delete]
    SubscriptionSegment:
        actAs:                 
            Temporal:
                unique_fields:              [subscription_id]
                parents:                    [Subscription]
                allow_past_modifications:   false
                shift_neighbors_on_save:    true
        columns:
            id:
                type:           integer(10)
                unsigned:       true
                primary:        true
                autoincrement:  true
            subscription_id:
                type:           integer(10)
                unsigned:       true
                notnull:        true
            licenses:
                type:           integer(2)
                unsigned:       true
                notnull:        true

Now, we can increment the license count without affecting existing license assignments - even though the subscription had started in the past:

    [php]
    $current_segment = $subscription->createNewTemporalSegment(); // NOTE: this returns a SubscriptionSegment object.
    $new_segment->licenses++;
    $new_segment->save();

We have just made the same change as before, but in this case the Subscription record remains untouched and we do not need to move or copy any LicenseAssignment records. 
A new SubscriptionSegment is created to handle the changed license count and the existing SubscriptionSegment is modified automatically during createNewTemporalSegment().

